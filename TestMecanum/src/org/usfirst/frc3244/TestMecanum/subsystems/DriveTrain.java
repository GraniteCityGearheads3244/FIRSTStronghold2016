// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3244.TestMecanum.subsystems;


import org.usfirst.frc3244.TestMecanum.RobotMap;
import org.usfirst.frc3244.TestMecanum.commands.*;

import edu.wpi.first.wpilibj.*;
import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class DriveTrain extends Subsystem {
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    SpeedController leftFrontDrive = RobotMap.driveTrainLeftFrontDrive;
    SpeedController leftRearDrive = RobotMap.driveTrainLeftRearDrive;
    SpeedController rightFrontDrive = RobotMap.driveTrainRightFrontDrive;
    SpeedController rightRearDrive = RobotMap.driveTrainRightRearDrive;
    AnalogGyro gyro = RobotMap.driveTrainGyro;
    Encoder leftRearEncoder = RobotMap.driveTrainLeftRearEncoder;
    Encoder rightRearEncoder = RobotMap.driveTrainRightRearEncoder;
    Encoder leftFrontEncoder = RobotMap.driveTrainLeftFrontEncoder;
    Encoder rightFrontEncoder = RobotMap.driveTrainRightFrontEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    
    
    
    //Start Code to use the NorticSpeedControler
    //******************************************
    NordicSpeedController nLF = RobotMap.nordicLF;
    NordicSpeedController nRF = RobotMap.nordicRF;
    NordicSpeedController nLR = RobotMap.nordicLR;
    NordicSpeedController nRR = RobotMap.nordicRR;
    RobotDrive robotDrive41 = RobotMap.driveTrainRobotDrive41;
    //******************************************
    //Stop Code to use the NorticSpeedControler
  
    BuiltInAccelerometer accelerometer = RobotMap.driveSystemaccel;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
        setDefaultCommand(new DriveRobotMecanum());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND
	
        // Set the default command for a subsystem here.
        //setDefaultCommand(new MySpecialCommand());
    }
    
    public void driveArcade(double moveValue, double rotateValue){
    	robotDrive41.arcadeDrive(moveValue, rotateValue);
    }
    
    
    public void driveMecanum(double x,double y,double rotation,double gyro){
    	//slow things down
       	robotDrive41.mecanumDrive_Cartesian(x, y, -rotation, gyro);
       
    }
   
    public void driveStop(){
    	robotDrive41.tankDrive(0, 0);
    }
    
    public double getGyro(){
    	return gyro.getAngle();
    }
    
    public double getAccelerometer(){
    	//complementary filter
    	//float angle_x = alpha*gyro_angle_x + (1.0 - alpha)*accel_angle_x;
    	return accelerometer.getZ();
    }
    
    public void updateStatus() {
    	
    	SmartDashboard.putNumber("Gyro", getGyro());
    	nLF.updateStatus();
       	nLR.updateStatus();
       	nRF.updateStatus();
       	nRR.updateStatus();
    }
    
    
    
    public double complementryFilter(){
    	
    	double alpha = 98;
    	double gyro_angle_x = getGyro();
    	double accel_angle_x = getAccelerometer();
    	
		return alpha*gyro_angle_x + (1.0 - alpha)*accel_angle_x;
    	
    }
    
    
//****************** Start Of My Supporting Logix **********************\\
    
    
    /**
     * 
     * @param target
     * @return
     */
    public double target(double target,double deadband, double min, double max){
    	if(Math.abs(target)<deadband){
    		target=0;
    	}
    	
    	//Check Target less than max
    	if(target>max){
    		target=max;
    	}
    	
    	//Check Target Greater Than Min
    	if(target<-max){
    		target=-max;
    	}
    	
    	return target;
    }
    
    /**
     * Use Current command speed commpared to Target speed then adds/sub
     * @param command
     * @param target
     * @return 
     */
    public double acc_dec (double command, double target, double rate){
    	if (target == 0){
    		// FAST STOP
    		command = command *.5;
    		if(Math.abs(command)<rate){			//If fast stop and command is less then rate the set command to 0
    			command = 0;
    		}
    	}else{ 									//Use rate to change command speed
    		if (command<target){				//If Accelerating add rate to command
    			command = command + rate;
    			if(command > target){			//If passed Target set command to Target
    				command = target;
    			}
    		}else if (command>target){			//If Decelerating subtract rate from command
    			command = command - rate;
    			if(command<target){
    				command = target;			//If passed Target set command to Target
    			}
    		}else{
    			command = command;				//Not Change needed
    		}
    	}
    	return command;
    }
    /**
     * Clamp Value between -1 and 1
     * @param command
     * @return 
     */
    public double clampCommand (double command){
    	if(command<-1){
    		return -1;
    	}else if (command > 1){
    		return 1;
    	}else{
    		return command;
    	}
    	
    }
}

