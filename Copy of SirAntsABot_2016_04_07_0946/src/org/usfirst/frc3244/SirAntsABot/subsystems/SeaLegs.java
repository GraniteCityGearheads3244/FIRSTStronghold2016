// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3244.SirAntsABot.subsystems;

import edu.wpi.first.wpilibj.RobotDrive;

import org.usfirst.frc3244.SirAntsABot.Robot;
import org.usfirst.frc3244.SirAntsABot.RobotMap;
import org.usfirst.frc3244.SirAntsABot.commands.*;
import edu.wpi.first.wpilibj.CANTalon;
import edu.wpi.first.wpilibj.Counter;
import edu.wpi.first.wpilibj.CounterBase.EncodingType;
import edu.wpi.first.wpilibj.DigitalInput;
import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.GenericHID;
import edu.wpi.first.wpilibj.PIDSourceType;

import edu.wpi.first.wpilibj.command.Subsystem;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;


/**
 *
 */
public class SeaLegs extends Subsystem {
	public boolean SeaLeg_Left_TDC_Found_FWD;
	public boolean SeaLeg_Right_TDC_Found_FWD;
	private boolean Motor_Left_Forward = true;
	private boolean Motor_Right_Forward = true;

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    private final CANTalon motor_Left = RobotMap.seaLegsMotor_Left;
    private final Encoder encoder_Left = RobotMap.seaLegsEncoder_Left;
    private final CANTalon motor_Right = RobotMap.seaLegsMotor_Right;
    private final Encoder encoder_Right = RobotMap.seaLegsEncoder_Right;
    private final DigitalInput limit_Switch_Left = RobotMap.seaLegsLimit_Switch_Left;
    private final DigitalInput limit_Switch_Right = RobotMap.seaLegsLimit_Switch_Right;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS

    Counter counter_SeaLeg_Left = new Counter(limit_Switch_Left);
    Counter counter_SeaLeg_Right = new Counter(limit_Switch_Right);

    NordicSpeedController nSeaLeg_L = RobotMap.nordicSeaLeg_Left;
    NordicSpeedController nSeaLeg_R = RobotMap.nordicSeaLeg_Right;
   
    RobotDrive seaLegeDrive21 = RobotMap.seaLegsSeaLeg_Drive;
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        setDefaultCommand(new SeaLegs_Jog_FWD());

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    }
    
    public void my_SeaLegs_drive_Tank(double leftValue, double rightValue){
    	
    	seaLegeDrive21.tankDrive(leftValue, -rightValue);
    	//SmartDashboard.putNumber("leftpower", leftValue);
    	//SmartDashboard.putNumber("rightpower", rightValue);
    }
    
    public void my_SeaLegs_Jog_Left(boolean forward,double power){
    	SmartDashboard.putNumber("power", power);
    	if (forward){
    		nSeaLeg_L.set(power);
    		Motor_Left_Forward = true;
    		//SmartDashboard.putBoolean("TestDIR", true);
    	}else{
    		nSeaLeg_L.set(-power);
    		Motor_Left_Forward = false;
    		//SmartDashboard.putBoolean("TestDIR", false);
    	}
    	
    }
    
    public void my_SeaLegs_Jog_Right(Boolean forward,double power){
    	if (forward){
    		nSeaLeg_R.set(power);
    		Motor_Right_Forward = true;
    	}else{
    		nSeaLeg_R.set(-power);
    		Motor_Right_Forward = false;
    	}
    	
    }
    
    public double target(double target,double deadband, double min, double max){
    	if(Math.abs(target)<deadband){
    		target=0;
    	}
    	
    	//Check Target less than max
    	if(target>max){
    		target=max;
    	}
    	
    	//Check Target Greater Than Min
    	if(target<-max){
    		target=-max;
    	}
    	
    	return target;
    }
    
    public void updateStatus(){
    	SmartDashboard.putNumber("SeaLeg Left Position", encoder_Left.getDistance());
    	SmartDashboard.putNumber("SeaLeg Right Position", encoder_Right.getDistance());
    	
    	if(Robot.seaLegs.my_SeaLeg_Left_At_TDC()){
    		Robot.oi.launchPad.setOutput(10, true);
    	}else{
    		Robot.oi.launchPad.setOutput(10, false);
    	}
    	if(Robot.seaLegs.my_SeaLeg_Right_At_TDC()){
    		Robot.oi.launchPad.setOutput(11, true);
    	}else{
    		Robot.oi.launchPad.setOutput(11, false);
    	}
    }
    
    //Home SeaLegs Logic
    //**************
    //  LEFT
    //**************
    public boolean my_SeaLeg_Left_At_TDC(){
    	return !limit_Switch_Left.get();
    }
    
    public boolean my_SeaLeg_Left_isSwitchSet() {
        return counter_SeaLeg_Left.get() > 0;
    }

    public void my_SeaLeg_Left_initializeCounter() {
        counter_SeaLeg_Left.reset();
    }
   
    public void my_Reset_Left_Encoder(){
    	encoder_Left.reset();
    }
    
    public double my_Get_Left_Encoder(){
    	return encoder_Left.getDistance();
    }
    
    //**************
    //  RIGHT
    //**************
    public boolean my_SeaLeg_Right_At_TDC(){
    	return !limit_Switch_Right.get();
    }
    
    public boolean my_SeaLeg_Right_isSwitchSet() {
        return counter_SeaLeg_Right.get() > 0;
    }

    public void my_SeaLeg_Right_initializeCounter() {
        counter_SeaLeg_Right.reset();
    }
    
    public void my_Reset_Right_Encoder(){
    	encoder_Right.reset();
    }
    
    public double my_Get_Right_Encoder(){
    	return encoder_Right.getDistance();
    }
}

