// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3018.Iajax.commands;
import org.usfirst.frc3018.Iajax.*;
import org.usfirst.frc3018.Iajax.subsystems.Pincher;

import edu.wpi.first.wpilibj.DriverStation;
import edu.wpi.first.wpilibj.command.Command;
import edu.wpi.first.wpilibj.command.CommandGroup;

/**
 *
 */
public class AutonomousCommand extends CommandGroup {
    
    public  AutonomousCommand() {
        // Add Commands here:
        // e.g. addSequential(new Command1());
        //      addSequential(new Command2());
        // these will run in order.

        // To run multiple commands at the same time,
        // use addParallel()
        // e.g. addParallel(new Command1());
        //      addSequential(new Command2());
        // Command1 and Command2 will run in parallel.

        // A command group will require all of the subsystems that each member
        // would require.
        // e.g. if Command1 requires chassis, and Command2 requires arm,
        // a CommandGroup containing them would require both the chassis and the
        // arm.
    	//addSequential(new PinchToHoldContainer());
    	//addSequential(new DriveForTime(0.5, 0.0, 0.0, true, 2.0));
    	this(Robot.getAutoScript());
    }

	public AutonomousCommand(String autoScript) {
		//parse autoScript string into sequence of commands
		String summary;
		String [] parts = autoScript.split(";");
		
		for(int i = 0; i < parts.length; i++){
	   	    String [] funcParts = parts[i].split("[()]");
	   	    
	   	    if(funcParts.length > 1){
	   	    	String [] args = funcParts[1].split(",");
	   	    	boolean isParallel = false;
	   	    	funcParts[0] = funcParts[0].trim();
	   	    	System.out.println(funcParts[0].substring(0,2).toUpperCase());
	   	    	
	   	    	if(funcParts[0].substring(0,2).toUpperCase().equals("P_")){
	   	    		System.out.println("found parallel command");
	   	    		funcParts[0] = funcParts[0].substring(2); 
	   	    		isParallel = true;
	   	    	}
	   	    	Command newCommand=null;	   	 
	   	    	

	   	 	    summary = "Building "+funcParts[0];
	   	    	switch(funcParts[0]) {
	   	    	case "DriveForTime":
	   	    		if(args.length == 5) {
	   	    			try {
	   	    				args[3] = args[3].trim().toUpperCase();
	   	    				newCommand = new DriveForTime(
		   	    					Double.parseDouble(args[0]),
		   	    					Double.parseDouble(args[1]),
		   	    					Double.parseDouble(args[2]),
		   	    					args[3]=="T" ? true:false,
		   	    					Double.parseDouble(args[4])
	   	    						);
	   	    			} catch(Exception ex) {
	   	    				summary += "\n    one of the values for drive for time was incorrect";
	   	    				//System.out.println("one of the values for drive for time was incorrect");
	   	    			}
	   	    		}
	   	    		else {
	   	    			summary += "\n    DriveForTime requires 5 arguments; " + args.length + " were given";
	   	    			//System.out.println("DriveForTime requires 5 arguments; " + args.length + " were given");
	   	    		}
	   	    		break;
	   	    	case "DriveToTote":
	   	    		newCommand = new DriveToTote();
	   	    		break;
	   	    	case "LiftFromGround":
	   	    		newCommand = new LiftFromGround();
	   	    		break;
	   	    	case "AdvanceCratesOnGround":
	   	    		newCommand = new AdvanceCratesOnGround();
	   	    		break;
	   	    	case "PinchToContainer":
	   	    		newCommand = new MovePincherToSetpoint(Pincher.PinchPosition.LIFT_CONTAINER_POSITION,true);
	   	    		break;
	   	    	case "MoveForks":
	   	    		if(args.length == 1) {
   	    			try {
   	    				newCommand = new MoveForks(
	   	    					Double.parseDouble(args[0])
   	    						);
   	    			} catch(Exception ex) {
   	    				summary += "\n    the value for Move Forks was incorrect";
   	    				//System.out.println("one of the values for drive for time was incorrect");
   	    			}
   	    		}
   	    		else {
   	    			summary += "\n    DriveForTime requires 5 arguments; " + args.length + " were given";
   	    			//System.out.println("DriveForTime requires 5 arguments; " + args.length + " were given");
   	    		}
   	    		break;
	   	    	case "RotateToAngle":
	   	    		if(args.length == 3) {
	   	    			try {
	   	    				args[2] = args[2].trim().toUpperCase();
	   	    				newCommand = new RotateToAngle(
		   	    					Double.parseDouble(args[0]),
		   	    					Double.parseDouble(args[1]),
		   	    					args[2]=="T" ? true:false
	   	    						);
	   	    			} catch(Exception ex) {
	   	    				summary += "\n    one of the values for rotate to angle was incorrect";
	   	    				//System.out.println("one of the values for rotate to angle was incorrect");
	   	    			}
	   	    		}
	   	    		else {
	   	    			summary += "\n    Rotate to angle requires 3 arguments; " + args.length + " were given";
	   	    			//System.out.println("Rotate to angle requires 3 arguments; " + args.length + " were given");
	   	    		}
	   	    		break;
	   	    		//to do: add DriveToAngle once it is finished
	   	    	
	   	    	case "AlignWithTote":
	   	    		if(args.length == 5) {
	   	    			try {
	   	    				newCommand = new AlignWithTote(
		   	    					Double.parseDouble(args[0]),
		   	    					Double.parseDouble(args[1]),
		   	    					Double.parseDouble(args[2]),
		   	    					Double.parseDouble(args[3]),
		   	    					Double.parseDouble(args[4])
	   	    						);
	   	    			} catch(Exception ex) {
	   	    				summary += "\n    one of the values for drive for time was incorrect";
	   	    				//System.out.println("one of the values for drive for time was incorrect");
	   	    			}
	   	    		}
	   	    		else {
	   	    			summary += "\n    AlignWithTote requires 4 arguments; " + args.length + " were given";
	   	    		}
	   	    		break;
	   	    		
	   	    	default:
	   	    		summary += "\n    " +funcParts[0] + " is not a valid command name";
	   	    		//System.out.println(funcParts[0] + " is not a valid command name");
	   	    	}
	   	    	if(newCommand!=null) {
   	   	    	    if(isParallel){
	   	    		    addParallel(newCommand);
	   	    		    summary += "\n    " +funcParts[0] + " addParallel";
	   	    		   //System.out.println(funcParts[0] + " addParallel");
	   	    	    } else {
	   	    		    addSequential(newCommand);
	   	    		    summary += "\n    " +funcParts[0] + " addSequential";
	   	    		    //System.out.println(funcParts[0] + " addSequential");
	   	    	    }   
	   	        }
	   	        DriverStation.reportError(summary + "\n", false);
	   	    }
		}
	}
}