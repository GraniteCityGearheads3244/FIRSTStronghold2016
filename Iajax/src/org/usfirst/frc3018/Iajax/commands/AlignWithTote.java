// RobotBuilder Version: 1.5
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc3018.Iajax.commands;

import edu.wpi.first.wpilibj.command.PIDCommand;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import org.usfirst.frc3018.Iajax.Robot;
import org.usfirst.frc3018.Iajax.RobotMap;

/**
 *
 */
public class  AlignWithTote extends PIDCommand {

	static final double TARGET_X = 165;
	static final double TARGET_Y = 143;
	static double MAX_SPEED = 0.5;
	private double m_noBlobDir = 1.0;
    public AlignWithTote(double P, double I, double D, double maxSpeed, double noBlobDir) {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID
        super("AlignWithTote", 0.01, 0.0, 0.0, 0.005);
        getPIDController().setContinuous(false);
        getPIDController().setAbsoluteTolerance(1.0);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=PID

        // Use requires() here to declare subsystem dependencies
        // eg. requires(chassis);

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.driveTrain);

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        MAX_SPEED = maxSpeed;
        getPIDController().setPID(P, I, D);
        //getPIDController().setOutputRange(-MAX_SPEED, MAX_SPEED);
        m_noBlobDir = noBlobDir;
    }
   
    public AlignWithTote() {
    	this(0.1, 0.0, 0.0, 0.5, 1.0);
    }

    protected double returnPIDInput() {
        // Return your input value for the PID loop
        // e.g. a sensor, like a potentiometer:
        // yourPot.getAverageVoltage() / kYourMaxVoltage;

        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
        return RobotMap.driveTrainGyro1.pidGet();

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=SOURCE
    }

    protected void usePIDOutput(double output) {
    	double pX = 0.01;
    	double pY = 0.01;
    	double errX=getErrorX();
    	double errY=getErrorY();
    	double xValue = pX*errX;
    	double yValue = -pY*errY;
    	if(Math.abs(xValue) > MAX_SPEED) {
    		xValue = MAX_SPEED*Math.abs(xValue)/xValue;
    	}
    	
    	if(Math.abs(yValue) > MAX_SPEED) {
    		yValue = MAX_SPEED*Math.abs(yValue)/yValue;
    	}
    	System.out.println("X="+Robot.visionTracking.getTopRightOfToteX()+" Y="+Robot.visionTracking.getTopRightOfToteY() + " bc="+Robot.visionTracking.getBlobCount());
    	System.out.println("errX=" + errX +" errY="+errY);
    	System.out.println("mecanum" + xValue + "," + yValue + "," + output);
    	SmartDashboard.putNumber("Align Setpoint" , getSetpoint());
    	SmartDashboard.putNumber("Align Rotation" , output);
    	SmartDashboard.putNumber("Align Foreward" , yValue);    
    	SmartDashboard.putNumber("Align Strafe" , xValue);
        Robot.driveTrain.mecanumDrive(xValue, yValue, output, 0.0);
    }
    double getErrorX() {
    	if(Robot.visionTracking.getBlobCount()==0.0){
    		return m_noBlobDir  * 320.0 -TARGET_X; 
    	}
    	return Robot.visionTracking.getTopRightOfToteX()-TARGET_X;

    }

    double getErrorY() {
    	if(Robot.visionTracking.getBlobCount()==0.0){
    		return 0.0;
    	}
    	return TARGET_Y - Robot.visionTracking.getTopRightOfToteY();
    }
    
    // Called just before this Command runs the first time
    protected void initialize() {
    	setSetpoint(90.0);
    	getPIDController().enable();
    	System.out.println("AlignWithTote initializing");
    }

    // Called repeatedly when this Command is scheduled to run
    protected void execute() {
    }

    // Make this return true when this Command no longer needs to run execute()
    protected boolean isFinished() {
        return Math.abs(getErrorX()) < 5 && Math.abs(getErrorY()) < 5 && getPIDController().onTarget();
    }

    // Called once after isFinished returns true
    protected void end() {
    	getPIDController().disable();
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    protected void interrupted() {
    	end();
    }
}
